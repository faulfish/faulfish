xiangqi-web/
├── index.html         # 前端 HTML 結構
├── style.css          # 前端樣式表
├── script.js          # 前端 JavaScript 邏輯
├── server.js          # 後端 Node.js 服務器
├── rules.js           # 象棋規則引擎
├── utils.js           # FEN 轉換等工具函數 (新增)
└── package.json       # Node.js 項目配置文件

項目名稱： 網頁版中國象棋分析板 (Web-based Xiangqi Analysis Board)
項目概述：
本項目是一個基於 Web 技術的中國象棋應用程序，主要設計為一個分析板 (Analysis Board) 或 沙盒 (Sandbox) 環境。它提供了一個交互式的象棋棋盤界面，允許用戶自由擺放局面、加載標準棋譜格式、逐步演示棋局進程，並支持多人（或多窗口）實時同步查看同一分析局面。與標準對弈模式不同，此分析板模式的核心在於移除了嚴格的輪流走棋限制，允許用戶在任何時候嘗試移動任何一方的棋子，主要用於棋局研究、複盤、教學演示或引擎測試。
核心功能：
圖形化棋盤界面: 使用 HTML Canvas 繪製標準的中國象棋棋盤和棋子，提供直觀的視覺效果。
自由走子 (分析板模式):
用戶可以在界面上點擊並嘗試移動任何一方的棋子。
後端規則驗證: 儘管前端允許自由操作，所有移動請求仍會發送到後端進行驗證。後端會檢查移動是否符合棋子的基本走法（車走直線、馬走日等）、是否吃子、是否滿足王不見王規則、以及移動後是否會導致走棋方自己被將軍 (自將)。但後端在此模式下會忽略當前的輪次 (gameState.turn)。
只有通過後端驗證的合法走法才會被接受並更新棋盤狀態。
實時狀態同步: 使用 WebSocket 技術實現前後端通信。棋盤狀態的任何合法更改（無論由哪個客戶端觸發）都會被後端廣播給所有連接到該分析板的客戶端，確保所有用戶看到的棋盤狀態實時同步。
棋譜處理 (FEN + 着法列表):
加載局面 (FEN): 支持粘貼標準的 FEN (Forsyth–Edwards Notation) 字符串到棋譜文本框，點擊“加載局面”按鈕後，後端會解析 FEN 並設置棋盤到指定局面。
加載着法列表: 支持在 FEN 之後（或從初始局面開始）粘貼使用 YYXX-YYXX 格式（例如 90-40 00-10）的着法列表。點擊“加載”按鈕後，前端會解析這些着法。
棋譜步進: 提供“下一步”和“回到開頭”按鈕。加載包含着法列表的棋譜後，用戶可以點擊“下一步”按鈕，由前端根據本地存儲的着法序列，本地驗證並執行棋譜中的下一步，更新界面顯示。
生成與複製: 提供“更新顯示”按鈕向後端請求當前局面的 FEN 和已走過的着法列表（YYXX-YYXX 格式），並顯示在文本框中。提供“複製棋譜”按鈕方便用戶將當前局面和歷史記錄複製到剪貼板。
多客戶端連接: 允許多個瀏覽器窗口或標籤頁連接到同一個後端分析板實例，共享和同步觀察同一個棋盤狀態。
技術棧：
前端:
HTML: 頁面結構
CSS: 頁面樣式
JavaScript: 核心交互邏輯、棋盤繪製 (Canvas API)、WebSocket 客戶端、棋譜解析與步進邏輯、DOM 操作。
後端:
Node.js: JavaScript 運行環境
ws 庫: 實現 WebSocket 服務器
JavaScript: 處理客戶端連接、消息路由、遊戲狀態管理、調用規則引擎進行驗證、FEN 處理。
核心模塊:
rules.js: 包含中國象棋的核心規則判斷函數 (棋子移動、將軍、將死、困斃、自將檢查)。
utils.js: 包含 FEN 字符串與棋盤狀態相互轉換的工具函數。
工作流程簡述：
後端 server.js 啟動，創建 WebSocket 服務。
客戶端通過瀏覽器訪問 index.html (經由 HTTP 服務器提供)。
script.js 執行，繪製棋盤並嘗試通過 WebSocket 連接到後端。
後端接受連接，創建或加入一個全局的分析板遊戲實例 (gameState)，並將初始棋盤狀態和輪次信息發送給客戶端。
客戶端接收信息，更新棋盤顯示。
用戶通過點擊棋盤進行操作：
直接移動: 點擊棋子 -> 點擊目標位置 -> script.js 發送 move 消息給後端 -> server.js 調用 rules.js 的 isValidMoveInternal 驗證 (忽略輪次但檢查規則和自將) -> 若合法，更新 gameState，通過 broadcast 將 update_state 發給所有客戶端；若非法，向發起者發送 illegal_move。
加載棋譜: 粘貼 FEN 或 FEN+着法 -> 點擊 "加載" -> script.js 提取 FEN，解析着法列表存儲在本地 -> 發送 load_fen 消息給後端 -> server.js 調用 utils.js 解析 FEN，更新 gameState -> 通過 broadcast 將 update_state 發給所有客戶端 -> script.js 更新棋盤，並啟用步進按鈕。
棋譜步進: 點擊 "下一步" -> script.js 從本地 loadedMoveHistory 取出下一步着法 -> 調用本地的驗證函數 (local_isValidMoveInternal) 檢查 -> 若合法，更新本地 boardState，currentMoveIndex++，redrawBoard()；若非法，顯示錯誤。
更新/複製棋譜: 點擊按鈕 -> script.js 向後端發送 get_game_record -> server.js 調用 utils.js 生成 FEN 和格式化歷史記錄 -> 發送 game_record 給客戶端 -> script.js 更新文本框 -> 用戶可複製。
目標用戶/用途：
象棋愛好者進行棋局分析和複盤。
象棋教學者用於演示特定局面或走法序列。
開發者測試象棋 AI 引擎或規則實現。
需要一個可以自由擺弄棋子、不受輪次限制的交互式棋盤的場景。